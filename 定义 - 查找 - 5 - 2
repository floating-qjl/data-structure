//散列表的查找
//处理冲突的方法：1.开放定址法（开地址法）
//                2.链地址法（拉链法）
//                3.再散列法（双散列函数法）
//                4.建立一个公共溢出区

//开放地址法
//基本思想：有冲突时就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到
//          并将元素存入
//例如：除留余数法 Hi = (Hash(key) + di) mod m           di为增量序列
//常用方法：线性探测法       di为1，2，3，…，m-1 线性序列
//          二次探测法       di为1^2，(-1)^2，2^2，(-2)^2，…，q^2 二次序列
//          伪随机探测法     di为伪随机数序列

//线性探测法：Hi = (Hash(key) + di) mod m (i <= i < m)
//            其中：m 为散列表长度，di 为增量序列 1，2，… m-1，且 di = 1
//            一旦冲突，就找下一个地址，直到找到空地址存入
//            在查找过程中，如果在相应地址（x%m）未找到，则依次向后寻找

//二次探测法：散列函数为 Hash(key) = key mod 11，Hi = (Hash(key) + di) mod m
//            其中：m 为散列表长度，m要求是某个 4k + 3 的质数
//                  di 为增量序列 1^2,-1^2,2^2,-2^2,…,q^2
//            可以探测一个地址的前后地址是否有冲突

//伪随机探测法：Hi = (Hash(key) + di) mod m（1 <= i < m）
//              其中：m 为散列表长度，di 为伪随机数



//链地址法（拉链法）
//基本思想：相同散列地址的记录链成一单链表
//          m 个散列地址就设 m 个单链表，然后用一个数组将 m 个单链表的表头指针存储起来
//          形成一个动态的结构
//          类似于 邻接表
//建立散列表步骤：1.取数据元素的关键字 key，计算其散列函数值（地址），若该地址
//                  对应的链表为空，则将该元素插入此链表，否则执行第二个步骤
//                2.根据选择的冲突处理方法，计算关键字 key 的下一个存储地址，
//                  若该地址对应的链表不为空，则利用链表的前插法或后插法将
//                  该元素插入到此链表
//优点：1.非同义词不会冲突，无“聚集”现象（原本的存储地址一样，但是值不一样）
//      2.链表上结点空间动态申请，更适合于表长不确定的情况

