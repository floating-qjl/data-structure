#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>

//线索二叉树
//当用二叉链表作为二叉树的存储结构时，可以很方便地找到某个结点的左右孩子；但一般情况下，无法直接找到该结点在某种遍历序列中的前去和后继结点

//如何寻找特定遍历序列中 二叉树结点的前驱和后继
//解决方法：1.通过遍历寻找 --- 费时间
//          2.再增设前驱、后继指针域 --- 增加了存储负担
//          3.利用二叉链表中的空指针域

//具有 n 个结点的二叉链表中，有 2n 个指针域，其中 n+1 为空指针域
//因此，如果某个结点的左孩子为空，则将空的左孩子指针域改为 指向其前驱
//      如果某个结点的右孩子为空，则将空的右孩子指针域改为 指向其后继
//      -------------这种 改变指向的指针 称为 “线索”
//加上了线索的二叉树称为 线索二叉树，对二叉树按某种遍历次序使其变为线索二叉树的过程叫做 线索化

//为区分 lchild 和 rchild 指针到底是指向孩子的指针，还是指向前驱或者后继的指针，对二叉链表中 每个结点增设两个标志域
//ltag 和 rtag，并约定：ltag = 0 lchild指向该结点的 左孩子
//                      ltag = 1 lchild指向该结点的 前驱
//                      rtag = 0 rchild指向该结点的 右孩子
//                      rtag = 1 rchild指向该结点的 后继
//这样，结点的结构为：lchild ltag data rtag rchild
typedef struct BiThrNode
{
	int data;
	int ltag, rtag;
	struct BiThrNode* lchild, * rchild;
}BiThrNode,*BiThrTree;

//我们发现，遍历序列时，第一个结点没有 前驱结点，最后一个结点没有 后继结点
//为方便操作，增设了一个头结点：
//ltag = 0，lchild 指向根结点
//rtag = 1，rchild 指向遍历序列中最后一个结点
//遍历序列中 第一个结点的 lc域 和 最后一个结点的 rc域 都指向头结点
