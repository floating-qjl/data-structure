#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//算法定义：对特定问题求解方法和步骤的一种描述，它是指令的有限序列。其中每个指令表示一个或多个操作

//算法描述：自然语言、流程图、伪代码（类语言）、程序代码

//算法与程序：算法 是解决问题的一种方法或一个过程，考虑如何将输入转换成输出，一个问题可以有多种算法
//            程序 是用某种程序设计语言对算法的具体实现
//                                    程序 = 数据结构 + 算法
//                                    数据结构通过算法实现操作
//                                    算法根据数据结构设计程序

//算法特性：有穷性：一个算法必须总是在执行有穷步之后结束，且每一步都在有穷时间内完成
//          确定性：算法中的每一条指令必须有确切的含义，没有二义性，在任何条件下，只有唯一的一条执行路径
//                  及对于相同的输入只能得到相同的输出
//          可行性：算法是可执行的，算法描述的操作可以通过已经实现的基本操作执行有限次来实现
//          输入：一个算法由零个或多个输入
//          输出：一个算法有一个或多个输出

//算法设计的要求：正确性：不含语法错误、对一切合法的输入数据结果正确
//                可读性：易与人的理解
//                健壮性：输入非法数据时，算法恰当的作出反应，而不是产生莫名其妙的结果，处理错误为返回错误的值
//                （鲁棒性）
//                高效性：要求花费尽量少的时间和尽量低的存储要求

//算法效率：空间效率：指的是算法执行过程中所耗费的存储空间
//          时间效率：指的是算法所耗费的时间
//          时间效率和空间效率有时候是矛盾的

//算法时间效率的度量：依据该算法编制的程序在计算机上执行所消耗的时间来度量
//方法：事后统计：将算法实现，测算其时间和空间开销
//      事前分析：对算法所消耗资源的一种估算方法
//                一个算法在计算机上运行所耗费的时间大致可以等于计算机执行一种简单的操作（赋值、比较、移动）
//                所需要的时间与算法中进行的简单操作次数乘积
//      算法运行时间 = 一个简单操作所需的时间 * 简单操作次数（每条语句执行次数 * 该语句执行一次所需的时间）
//                                                                语句频度             
//语句执行一次的时间随机器而异，因此假设执行每条语句所需的时间均为单位时间，这样就可以独立于不同机器的软硬件环境来分析算法的时间性能



int main()
{
	int a, b, c, d, e;
	int n = 10;
	for(a=1;a<=n;a++)
		//执行 n+1 次，最后一次判断单独算一次
		for (b = 1;b <= n;b++)
			//执行 （n+1）*n 次，n 次是 a 的次数
		{
			d = 1;//执行 n*n 次
			for (c = 0;c < n;c++)
				//执行 n*n*（n+1）次
				e = 0;
			//执行 n*n*n 次 
		}

	//我们把算法所耗费的时间定义为该算法中每条语句的频度之和，则上述算法的时间消耗为 T(n) = 2n^3 + 3n^2 + 2n + 1
	//但是这个方法较为复杂，因此便于比较，我们仅比较它们的数量级（越大的越不好）
	//若有某个辅助函数 f(n) ，使得当 n 趋近于无穷大时，T(n)/f(n)的极限值为不为零的常数
	//则称f(n)是T(n)的同数量级函数。记作T(n)=O(f(n))，称O(f(n))为算法的渐进时间复杂度，简称时间复杂度

	//比如此时的 T(n)，T(n)/n^3 是同阶或同数量级，引入大“O”记号，则 T(n) 可记作：T(n) = O(n^3)

	//算法中 基本语句重复执行的次数 是 问题规模n的某个函数 f(n) ，算法的时间量度记作：T(n) = O(f(n))
	//它表示 随着 n 的增大，算法执行的时间的增长率和 f(n) 的增长率相同，称 渐近时间复杂度

	//此时基本语句可重复执行的次数 为 对算法运行时间的贡献最大的，执行次数最多的一项

	//n越大算法的执行时间越长
	//排序：n为记录数   矩阵：n为矩阵的阶数   多项式：n为多项式的项数   集合：n为元素个数   树：n为树的结点个数
	//图：n为图的顶点数或边数

	return 0;
}
