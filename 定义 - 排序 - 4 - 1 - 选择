
//简单选择排序
//基本思想：在待排序的数据中选出最大的元素放在其最终的位置
//基本操作：1.首先通过n-1次关键字比较，从n个记录中找出关键字最小的记录，将它与第一个记录交换
//          2.再通过n-2次比较，从剩余的n-1个记录中找出关键字次小的记录，将它与第二个记录交换
//          3.重复上述操作，共进行n-1趟排序后，排序结束
void SelectSort(SqList& K)
{
	for (i = 1;i < L.length;i++)
	{
		k = i;
		for (j = i + 1;j <= L.length;j++)
			if (L.r[j].key < L.r[k].key)
				k = j;//记录最小值交换
		if (k != i)
			L.r[i]<-->L.r[k];//交换
	}
}
//时间复杂度

//记录移动次数
//最好情况：0
//最坏情况：3*(n - 1)
//比较次数
//无论待排序列处于什么状态，选择排序所需进行的“比较n - i”次数都相同
//为(n-i)从i=1到i=n-1的和，即为n/2*(n-1)
//即时间复杂度为：O(n^2)

//算法稳定性
//简单选择排序是不稳定排序

//需要额外辅助空间为O(1)

