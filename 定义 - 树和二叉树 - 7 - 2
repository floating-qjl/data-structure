#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//哈夫曼树的构造算法
//哈夫曼树中权最大的叶子离根越近
//贪心算法：构造哈夫曼树时首先选择权值小的叶子结点

//哈夫曼算法（构造哈夫曼树的方法）
//(1)根据 n 个给定的权值{W1,W1,…,Wn}构成 n 棵二叉树（只有根结点）的森林{T1,T2,…Tn}，其中Ti只有一个带权为Wi的根结点
//构造森林全是根
//(2)在F中选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和
//选用两小造新树
//(3)在F中删除这两棵树，同时将新得到的二叉树加入森林中
//删除两小添新人
//(4)重复(2)和(3)，直到森林中只有一棵树为止，这棵树即为哈夫曼树
//重复2、3剩单根

//哈夫曼树的结点的度数为 0 或 2，没有度为 1 的结点
//包含 n 个叶子结点的哈夫曼树中共有 2n - 1 个结点
//包含 n 棵树的森林要经过 n-1 次合并才能形成哈夫曼树，共产生 n-1 个新结点（都是度为2的结点）


//总结：1.在哈夫曼算法中，初始时有n棵二叉树，要经过n-1次合并最终形成哈夫曼树
//      2.经过n-1次合并产生n-1个新结点，且这n-1个新结点都是具有两个孩子的分支结点
//可见：哈夫曼树中共有 n+n-1 = 2n-1 个结点，且其所有的分支结点的度均不为 1
