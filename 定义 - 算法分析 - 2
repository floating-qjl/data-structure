#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//分析算法时间复杂度的基本方法：
//定理：1.若 f(n)=a*n^m + (a-1)*n^(m-1) + a 是m次的多项式，则 T(n) = O(n^m)   ---   忽略所有低次幂项和最高次幂系数
//        体现出增长率的含义
//（1）找出语句频度最大的那条语句作为基本语句
//（2）计算基本语句的频度得到问题规模 n 的某个函数 f(n)
//（3）取其数量级用符号“O”表示 

//最坏时间复杂度：值在最坏情况下，算法的时间复杂度
//平均时间复杂度：指在所有可能输入实例在等概率出现的情况下，算法的期望运行时间
//最好时间复杂度：指在最好的情况下，算法的时间复杂度
//一般总是考虑在最坏情况下的时间复杂度，以保证算法的运行时间不会比他更长

//对于复杂的算法，可以将它分成几个容易估算的部分，然后利用大O加法法则和乘法法则，计算算法的时间复杂度
//T(n) = T1(n) + T2(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))   ---   加法规则
//T(n) = T1(n) * T2(n) = O(f(n)) * O(g(n)) = O(f(n) * g(n))      ---   乘法规则

//当n取得很大时，指数时间算法和多项式，时间算法在所需时间上比较悬殊
//时间算法都 T(n) 按数量级递增顺序为：复杂度低---------->复杂度高
//常数阶 对数阶 线性阶 线性对数阶 平方阶 立方阶 …… K次方阶 指数阶




int main()
{
	int i = 1;
	while (i <= 0)
		i *= 2;
	//循环 1 次：i = 1*2 = 2^1
	//循环 2 次：i = 2*2 = 2^2
	//循环 3 次：i = 4*2 = 2^3
	//循环 x 次：i = 2^x

	//设该语句执行次数为 x ，由循环条件：i<=n，2^x<=n，x<=log2(n)
	//即 f(n)<=log2(n)，取最大值 f(n) = log2(n)
	//所以该程序段的时间复杂度 T(n) = O(log2(n))
	return 0;
}
