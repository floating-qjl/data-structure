
//插入排序
//基本思想：每步将一个待排序的对象，按其关键码大小，插入到前面已经排好序的
//          一组对象的适当位置上，直到对象全部插入为止
//即边插入边排序，保证子序列中随时都是排好序的

//基本操作：有序插入
//          在有序序列中插入一个元素，保持序列有序，有序长度不断增加
//          起初，a[0]是长度为1的子序列，然后，逐一将a[1]至a[n-1]插入到有序子序列中

//有序插入方法：再插入a[i]前，数组前半段为有序段，后半段是停留于输入次序的“无序段”
//              插入a[i]使a[0]到a[i-1]有序，也就是要为a[i]找到有序位置j，将a[i]插入到
//              j的位置上

//插入排序的种类：顺序法定位插入位置——直接插入排序
//                二分法定位插入排序——二分插入排序
//                缩小增量多遍插入排序—希尔排序

//直接插入排序——采用顺序查找法查找插入位置
//        操作：1.复制插入元素
//              2.记录后移，查找插入位置
//              3.插入到正确位置
//    使用哨兵：1.复制为哨兵（0号元素被赋值需要插入的数据）
//              2.记录后移，查找插入位置
//              3.插入到正确位置

//算法：
void InsertSort(SqList& L)
{
	int i, j;
	for (i = 2;i <= L.length;++i)
	{
		if (L.r[i].key < L.r[i - 1].key) //若 < ，需将L.r[i]插入到有序子表
		{
			L.r[0] = L.r[i];//复制为哨兵
			for (j = i - 1;L.r[0].key < L.r[j].key;--j)
			{
				L.r[j + 1] = L.r[j];//记录后移
			}
			L.r[j + 1] = L.r[0];//插入到正确位置
		}
	}
}
//实现排序的基本操作有两个：1.比较 序列中两个关键字的大小
//                          2.移动 记录

//最好的情况（关键字在记录序列中顺序有序）：
//“比较”的次数：n - 1
//“移动”的次数：0

//最坏的情况（关键字在记录序列中逆序有序）：
//“比较”的次数：(n+2)*(n-1)/2
//“移动”的次数：(n+4)*(n-1)/2

//平均情况：
//“比较”的次数：1/4 * (n+2)*(n-1)
//“移动”的次数：1/4 * (n+6)*(n-1)

//时间复杂度结论：
//原始数据越接近有序，排序速度越快
//最坏情况下（输入数据使逆有序的）：O(n^2)
//平均情况下（耗时差不多是最坏情况的一半）：O(n^2)
//最好情况下（输入数据是有序的）：O(n)
//要提高查找速度：1.减少元素的比较次数
//                2.减少元素的移动次数

