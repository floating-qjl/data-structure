//栈和递归
//递归的定义：若一个对象部分包含他自己，或用他自己给自己定义，则称这个对象是递归的
//若一个过程直接地或间接地调用自己，则称这个过程是递归的过程

//递归问题用分治法解决
//分治法：对于一个较为复杂的问题，能够分解成几个相对简单的且解法相同或类似的子问题来求解
//必备的三个条件：1.能将一个问题转变成一个新问题，而新问题与原问题的解法相同或类同，不同的仅是处理的对象
//                  且，这些处理对象是变化有规律的
//                2.可以通过上述转化而使问题简化
//                3.必须有一个明确的递归出口，或称递归的边界
void p(参数表)
{
	if (递归结束条件) 可执行语句;    -- - 基本项
	else p(较小的参数);    -- - 归纳项

}

//函数调用过程：1.调用前：将实参，返回地址等传递给被调用函数
//                        为被调函数的局部变量分配存储区
//                        将控制转移到被调用函数的入口
//              2.调用后：保存被调用函数的计算结果
//                        释放被调用函数的数据区
//                        依照被调用函数保存的返回地址将控制转移到调用函数

//多个函数构成嵌套调用时：遵循 后调用的先返回      和 栈 的规则相对应，因此可以使用栈来实现

//递归工作栈 --- 递归程序运行期间使用的数据存储区
//工作记录   ---   实在参数，局部变量，返回地址

//递归的优缺点：优点：结构清晰、程序易读
//              缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息，时间开销大

//递归 -> 非递归
//方法1：尾递归、单项递归 -> 循环结构
//方法2：自用 栈 模拟系统的运行时的 栈

//改写后的非递归算法与原来的递归算法相比，结构不够清晰，可读性差，有的还需要经过一系列优化
