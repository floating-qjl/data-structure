
//希尔排序

//直接插入排序在基本有序时，在待排序的记录个数较少，效率较高
//基本思想：先将整个待排记录序列分割成若干子序列，分别进行直接插入排序，待整个序列
//中的记录“基本有序”时，在对全体记录进行一次直接插入排序
//希尔排序算法特点：缩小增量，多遍插入排序

//思路：定义增量序列Dk：D(M) > D(M-1) > … > D1 = 1
//      对每个 D(k)进行“D(k)-间隔”插入排序

//特点：一次移动，移动位置较大，跳跃式地接近排序后的最终位置
//      最后一次只需要少量移动
//      增量序列必须是递减的，最后一个必须是1
//      增量序列应该是互质的

void ShellInsert(SqList& L, int dk)
{
	//对顺序表L进行一趟增量为dk的Shell排序，dk为步长因子
	for (i = dk + 1;i <= L.length;i++)
	{
		if (r[i].key < r[i - dk].key)
		{
			r[0] = r[i];
			for (j = i - dk;j > 0 && (r[0].key < r[j].key);j = j - dk)
				r[j + dk] = r[j];
			r[j + dk] = r[0];
		}
	}
}
void ShellSort(SqList& L, int dlta[], int t)//dk值依次存在dlta[]中
{
	//按增量序列dlta[0...t-1]对顺序表L作希尔排序
	for (k = 0;k < t;k++)
	{
		ShellInsert(L, dlta[k]);
	}
}
//希尔排序算法效率与增量序列的取值有关

//Hibbard增量序列
//D(k) = 2^(k-1) --- 相邻元素互质
//最坏情况：T(worst) = O(n^(3/2))
//猜想：T(avg) = O(n^(5/4))

//Sedgewick增量序列
//{1,5,19,41,109,...} 
//猜想：T(avg) = O(n^(7/6))
//      T(worst) = O(n^(4/3))

//希尔排序是一种不稳定的排序算法
//即相同的元素在经过希尔排序后相对位置会发生改变

//算法分析
//时间复杂度时n和d的函数：O(n^1.25)到O(1.6n^1.25) --- 经验公式
//空间复杂度为O(1)

//如何选择最佳d序列，目前尚未解决
//最后一个增量值必须为1，无除了1之外的公因子
//不宜在链式存储结构上实现
