#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include <string.h>

//遍历二叉树和线索二叉树
//遍历：顺着某一条搜索路径巡访二叉树中的结点，使得每个结点均被访问一次，且仅被访问一次（又称 周游）
//      访问的含义很广，可以是对结点做各种处理，但要求这种访问不破坏原来的数据结构
//目的：得到树中所有结点的一个线性排列
//用途：它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心

//遍历方法：依次遍历二叉树中的三个组成部分（根结点、左子树、右子树），便是遍历了整个二叉树
//假设：L 为左子树，R 为右子树，D 为根结点，则遍历整个二叉树方案共有：DLR、LDR、LRD、DRL、RDL、RLD六种，一般只研究前三种

//若规定 先左后右，则只有前三种情况：DLR --- 先（根）序遍历
//                                   LDR --- 中（根）序遍历
//                                   LRD --- 后（根）序遍历

//算法描述：1.先序遍历：若二叉树为空，则空操作；否则 访问根结点，先序遍历左子树，先序遍历右子树（递归思想）
//          2.中序遍历：若二叉树为空，则空操作，否则 中序遍历左子树，访问根结点，中序遍历右子树（递归思想）
//          3.后序遍历：若二叉树为空，则空操作，否则 后序遍历左子树，后序遍历右子树，访问根结点（递归思想）


//对于一个使用二叉树存储的 多项式 ，先序遍历得到，表达式的前缀表示（波兰式）
//                                  中序遍历得到，表达式的中缀表示
//                                  后序遍历得到，表达式的后缀表示（逆波兰）


//根据遍历序列确定二叉树
//若二叉树中各结点的值均不相同，则二叉树结点的先序序列、中序序列和后序序列 都是唯一的
//由二叉树的先序序列和中序序列，或后序序列和中序序列可以确定唯一一棵二叉树
//后序遍历，根结点必在后序序列尾部
//中序序列根结点左边为左子树，右边为右子树，以此利用递归思想，分布解决每一部分的结点位置
