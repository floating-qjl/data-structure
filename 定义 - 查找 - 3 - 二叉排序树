
//数表的查找

//当表插入、删除操作频繁时，为维护表的有序性，需要移动表中很多记录
//改用动态查找表 --- 几种特殊的数

//表结构在查找过程中动态生成
//对于给定值 key
//若表中存在，则成功返回，否则，插入关键字等于 key 的记录

//二叉排序树又称为 二叉搜索树、二叉查找树
//定义：二叉排序树或是空树，或是满足如下性质的二叉树
//      1.若其左子树非空，则左子树上所有结点的值均 小于根结点的值
//      2.若其右子树非空，则右子树上所有结点的值均 大于等于根结点的值
//      3.其左右子树本身又各是一棵二叉排序树（左子树上所有结点小于根结点的值）

//如果中序遍历二叉排序树，则得到的结果为 从小到大有序排列
//二叉排序树的性质：中序遍历非空的二叉排序树所得到的数据元素序列是一个按关键字排列的
//                  递增有序序列



//二叉排序树的查找操作
//若查找的关键字等于根结点，成功
//否则，若小于根结点，查其左子树
//      若大于根结点，查其右子树
//在左右子树上的操作类似

//二叉排序树的存储结构
typedef struct
{
	KeyType key;//关键字项
	InfoType otherinfo;//其他数据域
}ElemType;
typedef struct BSTNode
{
	ElemType data;//数据域
	struct BSTNode* lchild, * rchild;//左右孩子指针
}BSTNode,*BSTree;
BSTree T;//定义二叉排序树 T

//算法思想：1.若二叉排序树为空，则查找失败，返回空指针
//          2.若二叉排序树非空，将给定值 key 与根结点的关键字 T->data.key 进行比较
//            若 key 等于 T->data.key，则查找成功，返回根结点地址
//            若 key 小于 T->data.key，则进一步查找左子树
//            若 key 大于 T->data.key，则进一步查找右子树
//算法描述：
BSTree SearchBST(BSTRee T, KeyType key)
{
	if ((!T) || key == T->data.key)
		return T;
	else if (key < T->data.key)
		return SearchBST(T->lchild, key);//在左子树中继续查找
	else
		return SearchBST(T->rchild, key);//在右子树中继续查找
}

//二叉排序树上查找某关键字等于给定值的结点过程，其实就是走了一条从根到该结点的路径
//比较的关键字次数 = 此结点所在层次数 = 最多的比较次数 = 树的深度

//二叉排序树的平均查找长度：含有 n 个结点的二叉排序树的平均查找长度和数的形态有关
//最好情况：初始序列：{45，24，53，12，37，93}   按层排列的序列
//          ASL = log2(n+1) + 1
//          树的深度为：[log2(n)] + 1
//          与折半查找中的判定树相同
//          （形态比较均衡）：O(log2(n))

//最坏情况：初始序列：{12，24，37，45，53，93}   按层排列的序列
//          插入的 n 个元素从一开始就有序，变成单支树的形态
//          此时树的深度为 n，ASL = (n + 1)/2
//          查找效率与顺序查找情况相同：O(n)

//如何提高形态不均衡的二叉排序树的查找效率：
//解决方法：做“平衡化”处理，即尽量让二叉树的形状均衡 --- 均衡二叉树
