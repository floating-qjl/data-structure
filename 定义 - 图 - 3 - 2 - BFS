
//广度优先搜索（BFS）
//连通图
//方法：从图的某一结点出发，首先依次访问该结点的所有邻接顶点 vi1，vi2，……
//      再按这些顶点被访问的先后次序依次访问与他们相邻接的所有未被访问过的顶点
//      重复此过程，直到所有顶点均被访问为止

// 非连通图
//方法：先访问连通部分中所有顶点，在访问非连通部分



//广度优先搜索实现

//邻接表（类似树的层次遍历）
void BFS(Graph G,in v)//按广度优先非递归遍历连通图G
{
	cout << v;visited[v] = ture;//访问第v个顶点
	InitQueue(Q);//辅助队列Q初始化，置空
	EnQueue(Q, u);//v进队
	while (!QueueEmpty)//队列非空
	{
		DeQueue(Q, u);//队头元素出队并置为 u
		for (w = FirstAdjVex(G, u);w >= 0;w = NextAdjVex(G, u, w))
		{
			if (!visited[w])//w 为 u 的尚未访问的邻接顶点
			{
				cout << w;
				visited[w] = ture;
				EnQueue(Q, w);//w 进队
			}
		}
		
	}
}

//算法效率分析
//如果使用邻接矩阵，则BFS对于每一个被访问到的顶点，都要循环检测矩阵中的整整一行（n个元素）
//总的时间代价为 O(n^2)
//如果用邻接表来表示图，虽然有 2e 个表结点，但只需扫描 e 个结点即可完成遍历
//加上访问 n 个头结点的时间，时间复杂度为 O(n+e)


//DFS 与 BFS 算法效率比较
//空间复杂度相同，都是 O(n)（借用了堆栈或队列）
//时间复杂度只与存储结构（邻接矩阵或邻接表）有关，而与搜索路径无关
