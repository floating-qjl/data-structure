
#define _CRT_SECURE_NO_WARNINGS 1

//时间复杂度不计算时间，而是计算大概的运行次数

//时间复杂度
//在计算机科学中，算法的时间复杂度是一个函数，它定量描述了该算法的运行时间，一个算法执行所耗费的时间
//从理论上说，是不能算出来的，只有你把你的程序放在机器上跑起来，才能知道
//但是我们需要每个算法都上机测试吗？是可以都上机测试，但是这很麻烦，所以才有了时间复杂度这个分析方法
//一个算法所花费的时间与其中语句的执行次数成正比例，
//算法中的基本操作的执行次数，为算法的时间复杂度


//假设一个函数的基本操作执行次数为：n^2 + 2n + 10
//用大O的渐进式标为：O（n^2）

//实际中我们计算时间复杂度时，我们其实并不一定要计算精确的执行次数
//而只需要大概执行次数，那么这里我们使用大O的渐进表示法

//推导大O阶方法：
//1.用常数 1 取代运行时间中的所有加法常数
//2.在修改后的运行次数函数中，只保留最高阶段
//3.如果最高阶项存在且不是1，则去除与这个项目相乘的常数，得到的结果就是大O阶

//可以看出，大O渐进表示法去除了那些对结果影响不大的项，简洁明了的表示出了执行次数
//另外有些算法的时间复杂度存在最好，平均和最坏的情况：
//例如：在一个数组里面查找一个数
//最坏：任意输入规模的最大运行次数（上界）
//平均：任意输入规模的期望运行次数
//最好：任意输入规模的最小运行次数（下界）

//在实际中一般情况关注的是算法的最坏运行情况，所以数组中搜索数据时间复杂度为O（n）


//常见时间复杂度计算举例：
//1. 2n+1  -->  O(n)
//2. 100   -->  O(1)
//3. 二分查找 - 等差数列 - n/2/2/2/2/.../2 = 1 - n=2^x（x为查找次数） - x = log2(n)  -->  O(log2(n))
//这种方法查找次数增长很慢，看起来很好，但因为需要有序数组，因此这种算法较为鸡肋
//4.递归算法 递归次数*每次递归函数的次数 可能为 n*1  -->  O(n)
//  变种递归 fun1(n-1)+fun1(n-2) 次数为2^0+2^1+...+2^(n-1) 即为 2^n - 1 （所有递归都有效）
//  但实际上，此递归部分传参提前结束，导致部分递归为空，不过数量较少不影响整体，所以依然估算为 O（2^n）
