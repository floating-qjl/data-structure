#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//案例分析
//完成一元多项式的运算
//例如 P(X) = p0 + p1X + p2X^2 + ……
//算法分析：线性表 P = (p0,p1,p2,……)   每一项指数 i 隐含在其系数 pi 的序号中
//          而使用数组更加方便查找和运算，并且可以直接将对应的系数相加


//多项式非零项的数组表示
//此处若使用数组来存储的话需存储两个数值，即 系数与指数
//P = ((p1,e1),(p2,e2),……,(pm,em))
//线性表A = ((7,0),(3,1),(9,8),(5,17))
//线性表B = ((8,1),(22,7),(-9,8))
//算法分析：创建一个新数组c
//          分别从头遍历比较 a 和 b 的每一项
//          1.指数相同，对应系数相加，若其和不为零，则在c中增加一个新项
//          2.指数不同，则将指数较小的项复制到c中
//一个多项式已遍历完毕时，将另一个剩余项依次复制到c中即可
//此处 c 数组所取的大小可能为 0 或者 A+B，差距过大
//而这也是顺序存储结构存在的问题：1.存储空间分配不灵活 2.运算的空间复杂度高
//因此，可以使用 链式存储结构
typedef struct PNode
{
	float coef;//系数
	int expn;//指数
	struct PNode* next;//指针域
}PNode,*Polynomial;
//算法步骤：1.创建一个只有头结点的空链表
//          2.根据多项式的项的个数n，循环n次执行以下操作：
//            (1)生成一个新结点*s
//            (2)输入多项式当前项的系数和指数赋给新结点的数据域
//            (3)设置一前驱指针pre，用于指向待找到的第一个大于输入项指数的结点的前驱，pre初值指向头结点
//            (4)指针q初始化，指向首元结点
//            (5)循链 向下逐个比较链表中当前结点与输入项指数，找到第一个大于输入项指数的结点*q
//            (6)将输入项结点*s插入到结点*q之前
//即为 尾插法 或 头插法

//多项式创建
void CreatePolyn(Polynomial& P, int n)
{  //输入 n 项的系数和指数，建立表示多项式的有序链表P
	P = new PNode;
	P->next = NULL;//先建立一个带头结点的单链表
	for (i = 1;i <= n;i++)
	{ //依次输入 n 个非零项
		s = new PNode;//生成新结点
		cin >> s->coef >> s->expn;//输入系数和指数
		pre = P;//pre 用于保存 q 的前驱，初值为头结点
		q = P->next;//q初始化，指向首元结点
		while (q && Q->expn < s->expn)
		{   //找到第一个大于输入项指数的项*q
			pre = q;
			q = q->next;
		}
		s->next = q;//将输入项s插入到q和其前驱结点pre之间
		pre->next = s;
	}
}

//多项式相加
//算法步骤：1.指针 p1 和 p2 初始化，分别指向 pa 和 pb 的首元结点
//          2.p3 指向和多项式的当前结点，初值为 pa 的头结点
//          3.当指针 p1 和 p2 均未达到相应表尾时，则循环比较 p1 和 p2 所指向结点对应的指数值
//            当指数相等时，则将两个结点系数相加，若 和 不为零，修改 p1 所指结点系数，删除 p2 所指结点
//                                                若 和 为零，则删除 p1 和 p2 所指结点
//            当指数不等时，则应摘取指数较小的结点插入到“和多项式”链表中去
//          4.将非空多项式的剩余段插入到 p3 所指结点之后
//          5.释放 pb的头结点
int main()
{

	return 0;
}
