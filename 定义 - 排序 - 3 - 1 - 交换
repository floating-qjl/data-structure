
//交换排序
//基本思想：两两比较，如果发生逆序则交换，直到所有记录都排好序为止
//常见的交换排序方法：冒泡排序，快速排序

//冒泡排序
//基本思想：每趟不断将记录两两比较，并按“前小后大”规则交换
void bubble_sort(SqList& L)//冒泡排序算法
{
	int m, i, j;
	RedType x;//交换时临时存储
	for (m = 1;m <= n - 1;m++)//总共需要m趟
	{
		for (j = 1;j <= n - m;j++)
		{
			if (L.r[j].key > L.r[j + 1].key)//发生逆序
			{
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;//交换
			}
		}
	}
}
//优点：每趟结束时，不仅能挤出一个最大值到最后面位置，还能同时部分理顺其它元素
//提高效率：当某一趟比较不出现记录交换，说明已排好序了，就可以结束本算法
void bubble_sort(SqList& L)//改进的冒泡排序算法
{
	int m, i, j，flag = 1;//flag作为是否有交换的标记
	RedType x;//交换时临时存储
	for (m = 1;m <= n - 1;m++)//总共需要m趟
	{
		flag = 0;
		for (j = 1;j <= n - m;j++)
		{
			if (L.r[j].key > L.r[j + 1].key)//发生逆序
			{
				flag = 1;//发生交换，flag置为1，若本趟没发生交换，flag保持为0
				x = L.r[j];
				L.r[j] = L.r[j + 1];
				L.r[j + 1] = x;//交换
			}
		}
	}
}
//时间复杂度：最好情况（正序）
//            比较次数：n - 1
//            移动次数：0
//            最坏情况（逆序）
//            比较次数：(n - i)的从i = 1到i = n-1的和，即为1/2*(n^2 - n)
//            移动次数：3*【(n - i)的从i = 1到i = n的和】，即为3/2*(n^2 - n)

//冒泡排序最好时间复杂度是 O(n)
//冒泡排序最坏时间复杂度为 O(n^2)
//冒泡排序平均时间复杂度为 O(n^2)
//算法中增加一个辅助空间temp，辅助空间为 S(n) = O(1)
//冒泡排序是稳定的
