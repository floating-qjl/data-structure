
//堆的调整

//小根堆：1.输出堆顶元素之后，以堆中最后一个元素替代之
//        2.然后将根结点值与左右子树的根结点值进行比较，并与其中小者进行交换
//        3.重复上述操作，直至叶子结点，将得到新的堆，称这个从堆顶至叶子的调整过程为“筛选”
void HeapAdjust(elem R[], int s, int m)
{
	//已知R[s..m]中记录的关键字除R[s]之外均满足堆的定义，本函数调整R[s]的关键字，
	//使R[s..m]成为一个大根堆
	rc = R[s];
	for (j = 2 * s;j <= m;j *= 2)//沿key较大的孩子结点向下筛选
	{
		if (j < m && R[j] < R[j + 1])
			j++;//j为key较大的记录的下标
		if (rc >= R[j])
			break;
		R[s] = R[j];
		s = j;
	}
	R[s] = rc;
}
//可以看出，对一个无序序列反复筛选就可以得到一个堆，即：从一个无序序列建堆的过程
/           就是一个反复“筛选”的过程




//堆的建立
//显然：单节点的二叉树是堆，在完全二叉树中所有以叶子结点（序号i > n/2）为根的子树是堆
//      树中最后一个非叶子结点一定在 n/2 的位置
//      这样，我们只需要依次将以序号为n/2，n/2 - 1，...，1的结点为根的子树均调整为堆即可
//      即，对应由 n 个元素组成的无序序列，“筛选”只需从第 n/2 个元素开始

//由于堆实质上是一个线性表，那么我们可以顺序存储一个堆
//将乱序数据建立成一个完全二叉树，从最后一个非叶子节点开始，由此向前调整
//步骤：1.调整从第 n/2 个元素开始，将以该元素为根的二叉树调整为堆
//      2.将以序号为 n/2-1 的结点为根的二叉树调整为堆
//      3.再将以序号为 n/2-2 的结点为根的二叉树调整为堆
//注意：在多次调整过后，可能会出现原本已经调整好的又变成了乱序，因此调整的过程中要一直调整到叶子结点

//将初始无序的R[1]到R[n]建成一个小根堆，可用以下语句实现：
//for(i=n/2;i>=1;j--)
//HeapAdjust(R,i,n)



//堆的算法分析：
//实质上，堆排序就是利用了完全二叉树中父结点与孩子结点之间的内在关系来排序的
void HeapSort(elem R[])//对R[1]到R[n]进行堆排序
{
	int i;
	for (i = n / 2;i >= 1;i--)
		HeapAdjust(R, i, n);//建初始堆
	for (i = n;i > 1;i--)//进行 n-1 趟排序
	{
		Swap(R[1], R[i]);//根与最后一个元素交换
		HeapAdjust(R, 1, i - 1);//对R[1]到R[i-1]重新建堆
	}
}
//性能分析：初始堆化所需时间不超过O(n)
//排序阶段（不含初始堆化）：1.一次重新堆化所需时间不超过O(log(n))
//                          2.n-1次循环所需时间不超过O(nlog(n))
//Tw(n) = O(n) + O(nlog(n)) = O(nlog(n))

//堆排序的时间主要耗费在建初始堆和调整建新堆时进行的反复筛选上，堆排序在最坏情况下，
//其时间复杂度也为O(nlog2(n))，这是堆排序的最大优点，无论待排序列中的记录是正序还是
//逆序排列，都不会使堆排序处于“最好”或“最坏”的状态

//另外，堆排序只需一个记录大小供交换用的辅助存储空间
//然而堆排序是一种不稳定的排序方法，它不适用于待排序记录个数n较小的情况，但对于n较大
//的文件还是很有效的
