
//快速排序算法分析

//时间复杂度：可以证明，平均计算时间是O(nlog2(n))
//            Qsort():O(log2(n))
//            partition:O(n)
//实验结果表明：就平均计算时间而言，快速排序是我们所讨论的所有的排序算法中最好的一个

//空间复杂度：快速排序不是原地排序
//由于程序使用了递归，需要递归调用栈的支持，而栈的长度取决于递归调用的深度
//即使不用递归，也需要用到用户栈
//平均情况：需要O(log(n))的栈空间
//最坏情况：栈空间可达O(n)


//稳定性：快速排序是一种不稳定的排序方法

//若对原本有序或基本有序的记录序列进行排序，由于每次枢轴记录的关键字都是大于其他所有记录的关键字
//致使每一次划分后得到的子序列长度(1)的长度为0，这时已经退化成为没有改进措施得冒泡排序
//因此，快速排序不适于对原本有序或基本有序的记录进行排序

//划分元素的选取是影响时间性能的关键
//输入数据次序越乱，所选划分元素值的随机性越好，排序速度越快，快速排序不是自然排序方法
//改变划分元素的选取方法，至多只能改变算法平均情况下的世界性能，无法改变最坏情况下的时间性能
//即最坏情况下，快速排序的时间复杂性总是O(n^2)
