#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//串的模式匹配算法

//算法目的：确定主串中所含子串（模式串）第一次出现的位置（定位）
//算法应用：搜索引擎、拼写检查、语言翻译、数据压缩
//算法种类：BF算法  --- 暴力破解
//          KMP算法 --- 特点：速度快

//BF算法（简单匹配算法），采用穷举法的思路
//算法思想：从 S 的每一个字符开始依次与 T 的字符进行匹配
//将主串中的第 pos 个字符和模式串的第一个字符比较：
//若相等，继续逐个比较后续字符
//若不等，从主串的下一个字符起，重新与模式串的第一个字符比较
//直到主串的第一个连续子串字符序列与模式串相等，返回值为 S 中与 T 匹配的子序列第一个子符的符号，即匹配成功
//否则，匹配失败，返回值 0
int Index_BF(SString S, SString T)
{
	int i = 1;
	int j = 1;
	while (i <= S.length && j <= T.length)
	{
		if (s.ch[i] == t.ch[j])
		{
			++i;
			++j;
		}//主串和子串依次匹配下一个字符
		else
		{
			i = i - j + 2;
			j = 1;//主串、子串指针回溯重新开始下一次匹配，且主串字符位置+1
		}
		if (j >T.length)
			return i - T.length;//返回匹配的第一个字符的下标
		else
			return 0;//模式匹配不成功
	}
}

//时间复杂度：
//例如：S='0000000001'，T='0001'，pos=1
//若 n 为主串长度，m 为子串长度，最坏的情况是：
//主串前面 n-m 个位置都部分匹配到了子串的最后一位，及这 n-m 位各比较了 m 次
//总次数位：M = (n-m)*m+m=(n-m+1)*m         若m<<n，则时间复杂度为O(n*m)
//平均次数：X = (M+1)/2                     若m<<n，则时间复杂度为O(n*m)      
