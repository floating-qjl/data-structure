
//折半插入排序
//利用二分查找法进行插入
void BInsertSort(S)
{
	for (i = 2;i < L.length;++i) //依次插入第2到n个元素
	{
		L.r[0] = L.r[i];//当前插入元素存到“哨兵”位置
		low = 1;
		high = i - 1;//采用二分查找法查找插入位置
		while (low <= high)
		{
			mid = (low + high) / 2;
			if (L.r[0].key < L.r[mid].key)
				high = mid - 1;
			else
				low = mid + 1;
		}//循环结束，high + 1 则为插入位置
		for (j = i - 1;j >= high + 1;--j)
		{
			L.r[j + 1] = L.r[j];//移动元素
		}
		L.r[high + 1] = L.r[0];//插入到正确位置

	}
}
//折半查找比顺序查找快，所以折半插入排序就平均性能来说比直接插入排序要快

//他所需要的关键码比较次数与待排序对象序列的初始排序无关，仅依赖于对象个数
//再插入第i个对象时，需要经过 [log2(i)] + 1 次关键码比较，才能确定它应插入的位置

//当 n 较大时，总关键码比较次数比直接插入排序的最坏情况要好得多，但比起最好情况要差
//在对象的初始排序已经按关键码排好序或接近有序时，直接插入排序比折半插入排序执行的
//关键码比较次数要少

//折半插入排序的对象移动次数与直接插入排序相同 ，依赖于对象的初始序列
//折半插入排序减少了比较次数，但没有减少移动次数，平均性能优于直接插入排序

//时间复杂度为 O(n^2)
//空间复杂度为 O(1)
//是一种稳定的排序方法

