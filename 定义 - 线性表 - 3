#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//线性表的类型定义

//基本操作：lnitList(&L)      ---   操作结果：构造一个空的线性表
//          DestroyList(&L)   ---   操作结果：销毁线性表            初始条件：线性表 L 已经存在
//          ClearList(&L)     ---   操作结果：将线性表 L 重置为空   初始条件：线性表 L 已经存在
//          ListEmpty(L)      ---   操作结果：若线性表为空，则返回 TRUE ，否则返回 FALSE   初始条件：线性表 L 已经存在
//          ListLength(L)     ---   操作结果：返回线性表 L 中的数据元素个数   初始条件：线性表 L 已经存在
//          GetElem(L,i,&e)   ---   操作结果：用 e 返回线性表 L 中第 i 个数据元素的值   初始条件：线性表 L 已经存在
//          LocateElem(L,e,compare())   ---   操作结果：返回 L 中第一个与 e 满足compare()的数据元素的位序
//                                                      若这样的数据元素不存在则返回值为0
//                                            初始条件：线性表 L 已经存在，compare()是数据元素判定函数
//          PriorElem(L,cur_e,&pre_e)   ---   操作结果：若 cur_e 是 L 的数据元素，且不是第一个，则用 pre_e
//                                                      返回它的前驱，否则操作失败，pre_e无意义
//                                            初始条件：线性表 L 已经存在
//          NextElem(L,cur_e,&next_e)   ---   操作结果：若 cur_e 是 L 的数据元素，且不是最后一个，则用 next_e
//                                                      返回它的后继，否则操作失败，next_e无意义
//                                            初始条件：线性表 L 已经存在
//          Listlnsert(&L,i,e)          ---   操作结果：在 L 的第 i 个位置之前插入新的数据元素 e ，L 的长度加一
//                                            初始条件：线性表 L 已经存在，1<=i<=ListLength(L) + 1
//          ListDelete(&L,i,&e)         ---   操作结果：删除 L 的第 i 个数据元素，并用 e 返回其值，L 的长度减一
//                                            初始条件：线性表 L 已经存在，1<=i<=ListLength(L)
//          ListTraverse(&L,visited())  ---   操作结果：依次对线性表中每个元素调用visited()
//                                            初始条件：线性表 L 已经存在

//以上所提及的运算是逻辑结构上定义的运算，只要给出这些运算的功能“做什么”，
//至于“如何做”等实现细节，只有待确定了存储结构之后才考虑

int main()
{


	return 0;
}
