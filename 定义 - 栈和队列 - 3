#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//案例

//进制转换：
//十进制整数 N 向其他进制数 d（二，八，十六）的转换是计算机实现计算的基本问题
//转换法则：除以 d 倒取余
//n = (n div d) * d + n mod d
//其中，div 为整除运算，mod 为求余运算
//即为 辗转相除法
//例如：159/8 = 19……7       19/8 = 2……3       2/8 = 0……2
//所以，十进制数 159 转换为八进制数 就为 237


//括号匹配的检验：

//假设表达式中允许包含两种符号：圆括号和方括号
//其嵌套的顺序随意，即
//（【】（））或【（【】【】）】 为正确格式
//【（】）为错误格式
//（【（））或（（）】）为错误格式
//左括号入栈，若下一个括号不匹配，继续入栈，等匹配后出栈


//表达式求值
//表达式求值时程序设计语言便一种一个最基本的问题，他的实现也需要运用栈
//由运算符优先级确定运算顺序的对表达式求值算法   ---   算符优先算法
//操作数：常数、变量
//运算符：算术运算符、关系运算符和逻辑运算符
//界限符：左右括号和表达式结束符

//任何一个算术表达式都由操作数、算术操作符（+、-、*、/）和界限符（括号、表达式结束符'#'、虚设的表达时起始符'#'）组成，后两者统称为算符
//例如：# 3 * (7 - 2) #

//为了实现表达式求值，需要设置两个栈：
//一个是算符栈OPTR，需要寄存运算符
//另一个称为操作数栈OPND，用于寄存运算数和运算结果

//求值的处理过程时自左至右扫描表达式的每一个字符
//当扫描到的是运算数，则将其压入栈OPND
//当扫描到的是运算符时：1.若这个运算符比OPTR栈顶运算符的优先级高，则入栈OPTR，继续向后处理
//                      2.若这个运算符比OPTR栈顶运算符优先级低，则从OPND栈中弹出两个运算数，从栈OPTR中弹出栈顶运算符进行运算，并将运算结果压入栈OPND
//继续处理当前字符，直到遇到结束符为止
//                     


//舞伴问题
//假设在舞会上，男士和女士各自排成一对，舞会开始时，依次从男队和女队的队头各出一人配成舞伴，如果两队初始人数不同
//则较长的那一队中未匹配者等待下一轮舞曲，现要求写一算法模拟上述舞伴配对问题

//显然，先入队的男士或女士先出队配成舞伴，因此该问题具有典型的先进先出特性，可以用队列作为算法的数据结构

//首先构造两个队列
//依次将队头元素出队配成舞伴
//某队为空，则另外一队等待着下一舞曲
int main()
{
	return 0;
}
