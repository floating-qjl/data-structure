//图的遍历
//定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中所有顶点，且使每个顶点仅被访问一次
//      就叫做图的遍历，它是图的基本运算
//遍历实质：找每个顶点的临界点的过程

//图的特点：图中可能存在回路，且图的任一顶点都可能与其他顶点相通，在访问完某个顶点之后可能会沿着
//          某些便又回到了曾经访问过的顶点

//怎么避免重复访问？
//解决思路：设置辅助数组 visit[n]，用来标记每个被访问过的顶点
//          初始状态 visit[i]为 0
//          顶点 i 被访问，改 visit[i] 为 1，防止被多次访问

//图常用的遍历：1.深度优先搜索（DFS）
//              2.广度优先搜索（BFS）

//DFS：1.在访问图中某一起始顶点 v 后，由 v 出发，访问它的任一邻接顶点 w1
//     2.再从 w1 出发，访问与 w1 邻接但还未被访问过的顶点 w2
//     3.然后再从 w2 出发，进行类似的访问
//     4.如此进行下去，直至到达所有的邻接顶点都被访问过的顶点 u 为止
//     5.接着，退回一步，退到前一次刚访问过的顶点，看是否还有其它没有被访问的邻接顶点
//       (1).如果有，则访问此顶点，之后再从此顶点出发，进行与前述类似的访问
//       (2).如果没有，就再退回一步进行搜索，重复上述过程，直到连通图中所有顶点都被访问过为止

//连通图的 深度优先遍历 类似于 树的先根遍历


//邻接矩阵表示的无向图深度遍历实现：
void DFS(AMGraph G, in v) //图 G 为邻接矩阵类型
{
	cout << v;
	visited[v] = ture;//访问第 v 个顶点
	for (w = 0;w < G.vexnum;w++)//依次检查邻接矩阵 v 所在的行
	{
		if ((G.arcs[v][w] != 0) && (!visited[w]))//有边链接，且未访问过
			DFS(G, w);
		//w 是 v 的邻接点，如果 w 未访问，则递归调用 DFS
	}
}
