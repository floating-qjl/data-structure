#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

//哈夫曼编码
//在远程通讯中，要将待传字符转换成由二进制组成的字符串
//若将编码设计为长度不等的二进制编码，即让待传字符串中出现次数较多的字符采用尽可能短的编码
//则转换的二进制字符串便可能减少
//例如：ABACCDA      A - 0
//                   B - 00
//                   C - 1
//                   D - 01
//编码为：000011010
//但此时会出现 重码，不能将二进制编码转换回去
//关键：要设计长度不等的编码，则必须使任意字符的编码都不是另一个字符编码的前缀（前缀编码）

//此时就可以使用 哈夫曼编码：不会出现重码，且编码总长最短
//方法：1.统计字符集中每个字符在电文中出现的平均概率（概率越大，要求编码越短）
//      2.利用哈夫曼树的特点：权越大的叶子离根越近；将每个字符的概率值作为权值，构造哈夫曼树
//        则概率越大的结点，路径越短
//      3.在哈夫曼树的每个分支上标上 0 或 1
//        结点的左分支标 0，右分支标 1
//        把从根到每个叶子的路径上的标号连接起来，作为该叶子代表的字符的编码

//为什么哈夫曼编码能够保证是前缀编码？
//因为没有一片树叶是另一片树叶的祖先，所以每个叶结点的编码就不可能是其它叶结点编码的前缀

//为什么哈夫曼编码能够保证字符编码总长最短？
//因为哈夫曼树的带权路径长度最短，故字符编码的总长最短

//性质：1.哈夫曼编码是前缀码
//      2.哈夫曼编码是最优前缀码

//可以直接用权重表示字符出现的概率
